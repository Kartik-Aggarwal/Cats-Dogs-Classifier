import numpy as np
from scipy.spatial import Delaunay

def tri_area(p1, p2, p3):
    return 0.5 * np.abs(np.cross(p2 - p1, p3 - p1))

def tri_centroid(p1, p2, p3):
    return (p1 + p2 + p3) / 3.0

def inpolygon(p, pv):
    n = len(pv)
    inside = False
    for i in range(n):
        j = (i + 1) % n
        if ((pv[i, 1] <= p[1] and p[1] < pv[j, 1]) or
            (pv[j, 1] <= p[1] and p[1] < pv[i, 1])):
            if (p[0] < (pv[j, 0] - pv[i, 0]) * (p[1] - pv[i, 1]) / (pv[j, 1] - pv[i, 1]) + pv[i, 0]):
                inside = not inside
    return inside

def create_node_points(pv, hmax):
    node_points = []
    n = len(pv)
    for i in range(n - 1):  # Exclude the last point (closed polygon)
        p1, p2 = pv[i], pv[i + 1]
        segment_length = np.linalg.norm(p2 - p1)
        num_points = max(int(segment_length / hmax), 1)
        delta = (p2 - p1) / num_points
        for j in range(num_points):
            node_points.append(p1 + j * delta)
    return np.array(node_points)

def pmesh(pv, hmax):
    p = create_node_points(pv, hmax)
    t = Delaunay(p)
    centroids = np.array([tri_centroid(p[t.vertices[i, 0]], p[t.vertices[i, 1]], p[t.vertices[i, 2]]) for i in range(len(t.simplices))])
    
    while True:
        large_triangles = []
        for i, triangle in enumerate(t.simplices):
            area = tri_area(p[triangle[0]], p[triangle[1]], p[triangle[2]])
            if area > hmax ** 2 / 2.0:
                large_triangles.append(i)
        if not large_triangles:
            break
        
        new_points = []
        for tri_index in large_triangles:
            centroid = centroids[tri_index]
            if inpolygon(centroid, pv):
                new_points.append(centroid)
        
        if not new_points:
            break
        
        p = np.vstack([p, new_points])
        t = Delaunay(p)
        centroids = np.array([tri_centroid(p[t.vertices[i, 0]], p[t.vertices[i, 1]], p[t.vertices[i, 2]]) for i in range(len(t.simplices))])
    
    return p, t.simplices




Auditor Manager	User Type	EOD Type	Process Type	User	Current Week Filter	Domain	Responsible Party	Role	SCAC	Bot Check	Date_Worked	Inbound_SCAC	Invoice_SCAC	Queue Posting Type	Bot Entries	Goal	Manual Entries	Percentage of Goal	180+ Invoices	Account	Aggregate to Weeks	Audit Manager	Auditor	Bot Entries	Carrier Claimed Amount	COE	Current Date Filter	Delivery_Date	Denied Amount	Denied Amount	EOD Label for Donut	EOD Touches	EOD Touches	Fin_Doc_Header_ID	Group	Group2	High Dollar Invoices	High Dollar Invoices	Highest Approved	Initial Discrepancy Amount	Invoice Approved Amount	Invoice_Amount	Invoice_Carrier	Invoice_Created_Date	Invoice_Currency	Invoice_Date	Invoice_Number	Invoice_Receipt_Date	Invoice_Status	Last 4 Weeks Filter	Manual Entries	ME_ID	Final Fatal Error	Mode_Type	No. Weeks	Number of Records	Operations VP	Previous Sunday	Queue Movement	Queue Movement	Queue_Posted_to	Resolution Comment	RFB_Date	Right_Group	Right_Group2	Rolling Average Filter	Service_Group	Ship_Date	Short Paid Amount	TaskType	TaskTypeNote	Tenure Date	TMSFQueue	TMSFQueueID	TMSFStatus	TMSFStatusID	Total Approved	Updated Count	Weekly Completions Target	Weekly Goal	Weekly Production Average	Worked Date No Time




error: subprocess-exited-with-error
  
  Getting requirements to build wheel did not run successfully.
  exit code: 1
  
  [20 lines of output]
  Traceback (most recent call last):
    File "C:\ProgramData\anaconda3\Lib\site-packages\pip\_vendor\pyproject_hooks\_in_process\_in_process.py", line 353, in <module>
      main()
    File "C:\ProgramData\anaconda3\Lib\site-packages\pip\_vendor\pyproject_hooks\_in_process\_in_process.py", line 335, in main
      json_out['return_val'] = hook(**hook_input['kwargs'])
                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    File "C:\ProgramData\anaconda3\Lib\site-packages\pip\_vendor\pyproject_hooks\_in_process\_in_process.py", line 118, in get_requires_for_build_wheel
      return hook(config_settings)
             ^^^^^^^^^^^^^^^^^^^^^
    File "C:\Users\kartik225832\AppData\Local\Temp\1\pip-build-env-kjtzk_2a\overlay\Lib\site-packages\setuptools\build_meta.py", line 325, in get_requires_for_build_wheel
      return self._get_build_requires(config_settings, requirements=['wheel'])
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    File "C:\Users\kartik225832\AppData\Local\Temp\1\pip-build-env-kjtzk_2a\overlay\Lib\site-packages\setuptools\build_meta.py", line 295, in _get_build_requires
      self.run_setup()
    File "C:\Users\kartik225832\AppData\Local\Temp\1\pip-build-env-kjtzk_2a\overlay\Lib\site-packages\setuptools\build_meta.py", line 487, in run_setup
      super().run_setup(setup_script=setup_script)
    File "C:\Users\kartik225832\AppData\Local\Temp\1\pip-build-env-kjtzk_2a\overlay\Lib\site-packages\setuptools\build_meta.py", line 311, in run_setup
      exec(code, locals())
    File "<string>", line 10, in <module>
  ValueError: Detected unsupported operating system: win32. Please check the compability information of auto-sklearn: https://automl.github.io/auto-sklearn/master/installation.html#windows-osx-compatibility
  [end of output]
  
  note: This error originates from a subprocess, and is likely not a problem with pip.
error: subprocess-exited-with-error

Getting requirements to build wheel did not run successfully.
exit code: 1

See above for output.

note: This error originates from a subprocess, and is likely not a problem with pip.


Pro Nbr	Biller Dt Tm	Scan Dt	Origin Terminal Cd	Destination Terminal Cd	Purchase Order #	Bill Of Lading #	Pick Up Dt	Shipper #	Shipper Name	Shipper Address	Shipper City	Shipper State	Shipper Zip	Consignee #	Consignee Name	Consignee Address	Consignee City	Consignee State	Consignee Zip	Bill To #	Bill To Type Cd	Bill To Name	Bill To Address	Bill To City	Bill To State	Bill To Zip	COD Amt	Pickup SCAC	Pallet Cnt	Total Wgt	Is Hazmat	User Id	CL Pro Nbr	Biller	Reference Pro #	Initial Amount	Fatal_Error	Non-Fatal Error	Error


from sklearn.ensemble import AdaBoostClassifier
svc = SVC(probability=True, kernel='linear')
abc = AdaBoostClassifier(n_estimators=50, estimator=svc)
model = abc.fit(X_train, y_train)
pred = model.predict(X_test)
recall_score(y_test, pred), precision_score(y_test, pred), f1_score(y_test, pred)

import pandas as pd
from sklearn.tree import DecisionTreeClassifier

data = pd.DataFrame()
data['A'] = ['a','a','b','a']
data['B'] = ['b','b','a','b']
data['C'] = [0, 0, 1, 0]
data['Class'] = ['n','n','y','n']

tree = DecisionTreeClassifier()

one_hot_data = pd.get_dummies(data[['A','B','C']],drop_first=True)
tree.fit(one_hot_data, data['Class'])



label_encoders = {}
for col in non_numeric_cols:
    label_encoders[col] = LabelEncoder()
    df[col] = label_encoders[col].fit_transform(df[col])

# Compute correlation matrix
correlation_matrix = df.corr()

print(correlation_matrix)
