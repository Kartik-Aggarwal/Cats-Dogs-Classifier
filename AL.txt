[
  {
    "id": 1,
    "vehicleId": 101,
    "fuelCost": 3.50,
    "laborCost": 20.00
  },
  {
    "id": 2,
    "vehicleId": 102,
    "fuelCost": 3.75,
    "laborCost": 22.50
  }
]
[
  {
    "id": 3,
    "vehicleId": 103,
    "fuelCost": 3.60,
    "laborCost": 21.00
  },
  {
    "id": 4,
    "vehicleId": 104,
    "fuelCost": 3.65,
    "laborCost": 21.50
  },
  {
    "id": 5,
    "vehicleId": 105,
    "fuelCost": 3.55,
    "laborCost": 20.50
  },
  {
    "id": 6,
    "vehicleId": 106,
    "fuelCost": 3.70,
    "laborCost": 22.00
  },
  {
    "id": 7,
    "vehicleId": 107,
    "fuelCost": 3.45,
    "laborCost": 19.50
  },
  {
    "id": 8,
    "vehicleId": 108,
    "fuelCost": 3.80,
    "laborCost": 23.00
  },
  {
    "id": 9,
    "vehicleId": 109,
    "fuelCost": 3.75,
    "laborCost": 22.50
  },
  {
    "id": 10,
    "vehicleId": 110,
    "fuelCost": 3.85,
    "laborCost": 24.00
  },
  {
    "id": 11,
    "vehicleId": 111,
    "fuelCost": 3.40,
    "laborCost": 19.00
  },
  {
    "id": 12,
    "vehicleId": 112,
    "fuelCost": 3.90,
    "laborCost": 25.00
  },
  {
    "id": 13,
    "vehicleId": 113,
    "fuelCost": 3.95,
    "laborCost": 26.00
  },
  {
    "id": 14,
    "vehicleId": 114,
    "fuelCost": 3.50,
    "laborCost": 20.00
  },
  {
    "id": 15,
    "vehicleId": 115,
    "fuelCost": 3.55,
    "laborCost": 20.50
  },
  {
    "id": 16,
    "vehicleId": 116,
    "fuelCost": 3.60,
    "laborCost": 21.00
  },
  {
    "id": 17,
    "vehicleId": 117,
    "fuelCost": 3.65,
    "laborCost": 21.50
  },
  {
    "id": 18,
    "vehicleId": 118,
    "fuelCost": 3.70,
    "laborCost": 22.00
  },
  {
    "id": 19,
    "vehicleId": 119,
    "fuelCost": 3.75,
    "laborCost": 22.50
  },
  {
    "id": 20,
    "vehicleId": 120,
    "fuelCost": 3.80,
    "laborCost": 23.00
  }
]





<Box
    gridColumn="span 6"
    gridRow="span 1"
    backgroundColor={'#f2f0f0'}
    display="flex"
    alignItems="center"
    justifyContent="center"
    >
    <Typography gutterBottom variant="h5" component="div">
    Each location must be visited exactly once  
    </Typography>
</Box>


<React.Fragment>
        <Box
          gridColumn="span 8"
          gridRow="span 2"
          backgroundColor={colors.primary[400]}
          onClick={handleClickOpen}
        >
          <Dialog
        open={open}
        onClose={handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
        fullWidth={true}
        maxWidth='xl'
        onClick={(e) => e.stopPropagation()}
      >
        <DialogTitle  id="alert-dialog-title">
        </DialogTitle>
        <DialogContent>
        <Contacts />
          {/* <DialogContentText id="alert-dialog-description">
            Let Google help apps determine location. This means sending anonymous
            location data to Google, even when no apps are running.
          </DialogContentText> */}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>Close</Button>
          {/* <Button onClick={handleClose} autoFocus>
            Agree
          </Button> */}
        </DialogActions>
      </Dialog>
        </React.Fragment>



Yes, you can optimize your React component by using an array to store your constraint details and then mapping over this array to dynamically render the Accordion components. This approach allows you to avoid repetitive code and efficiently generate multiple Accordion elements with unique content. Here's an example of how you can achieve this:

```jsx
import React from 'react';
import { Accordion, AccordionSummary, AccordionDetails, Typography } from '@material-ui/core';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';

const constraintData = [
  {
    title: 'Each location must be visited exactly once',
    description: 'This constraint ensures that every stop in the route is covered efficiently without revisiting the same location. By adhering to this rule, route optimization algorithms can focus on finding the shortest or most time-efficient path that fulfills all required visits.',
  },
  {
    title: 'Sales representative must return to starting location',
    description: 'Requiring the representative to return to the starting point ensures the completion of a round trip. This constraint impacts route planning significantly, influencing the sequence and order of visited locations to optimize both time and distance.',
  },
  // Add more constraint objects as needed
];

const RouteConstraintsAccordion = () => {
  return (
    <>
      {constraintData.map((constraint, index) => (
        <Accordion key={index} defaultExpanded>
          <AccordionSummary
            expandIcon={<ExpandMoreIcon />}
            aria-controls={`panel${index + 1}-content`}
            id={`panel${index + 1}-header`}
          >
            <Typography>{constraint.title}</Typography>
          </AccordionSummary>
          <AccordionDetails>
            <Typography>{constraint.description}</Typography>
          </AccordionDetails>
        </Accordion>
      ))}
    </>
  );
};

export default RouteConstraintsAccordion;
```

In this example:

- `constraintData` is an array of objects where each object represents a route optimization constraint. Each object contains a `title` (constraint heading) and a `description` (explanation of the constraint).
- The `RouteConstraintsAccordion` component maps over the `constraintData` array to dynamically render multiple `Accordion` components based on the data in the array.
- Inside the `map` function, each `Accordion` component is rendered with its respective `AccordionSummary` (using the constraint title as the summary) and `AccordionDetails` (using the constraint description).

By using this approach, you can easily manage and update your route optimization constraints in the `constraintData` array without having to manually duplicate and modify the Accordion components in your React code. Each constraint is rendered dynamically based on the data provided in the array.



<Accordion defaultExpanded>
        <AccordionSummary
          expandIcon={<ExpandMoreIcon />}
          aria-controls="panel1-content"
          id="panel1-header"
        >
          <Typography>Each location must be visited exactly once</Typography>
        </AccordionSummary>
        <AccordionDetails>
          <Typography>
          This constraint ensures that every stop in the route is covered efficiently without revisiting the same location. By adhering to this rule, route optimization algorithms can focus on finding the shortest or most time-efficient path that fulfills all required visits.
          </Typography>
        </AccordionDetails>
      </Accordion>

1. **Each location must be visited exactly once**: This constraint ensures that every stop in the route is covered efficiently without revisiting the same location. By adhering to this rule, route optimization algorithms can focus on finding the shortest or most time-efficient path that fulfills all required visits.

2. **Sales representative must return to starting location**: Requiring the representative to return to the starting point ensures the completion of a round trip. This constraint impacts route planning significantly, influencing the sequence and order of visited locations to optimize both time and distance.

3. **Time window constraints**: Time windows specify the permissible time range for arriving at and departing from each location. Adhering to these constraints is crucial to meeting customer commitments and avoiding penalties for late deliveries, making route planning more complex but essential for customer satisfaction.

4. **Capacity constraints if sales representative is carrying goods**: If the sales representative is transporting goods, capacity constraints come into play. Each location may have a limit on the amount of goods that can be delivered or picked up, necessitating careful consideration in the route plan to avoid exceeding these limits.

5. **Vehicle-specific and traffic-specific constraints**: Different vehicles may have varying capabilities and limitations, such as maximum speed, weight limits, or fuel constraints. Traffic conditions and road characteristics also impact route optimization, requiring algorithms to account for these factors to ensure safe and efficient navigation. These constraints influence route decisions to optimize vehicle performance and compliance with regulations.

Certainly! Here are additional headings and constraint details relevant to route optimization in logistics:

6. **Geographical Constraints**: Certain routes may be restricted due to geographical factors like road closures, bridges, tolls, or restricted areas. Route optimization algorithms must consider these constraints to plan feasible and legal paths.

7. **Vehicle Types and Features**: Different vehicles (e.g., trucks, vans, cars) have unique capabilities and limitations. Constraints such as vehicle dimensions, turning radius, and special equipment requirements (like refrigeration) affect route planning to ensure vehicle suitability for each segment of the journey.

8. **Dynamic Traffic Conditions**: Real-time traffic information influences route choices to avoid congestion and delays. Algorithms must incorporate traffic patterns, accidents, and road closures to adjust routes dynamically for optimal efficiency.

9. **Environmental Factors**: Constraints related to environmental regulations, emission zones, or eco-friendly routes may influence route selection to minimize ecological impact and adhere to sustainability goals.

10. **Service Time Constraints**: Some locations may require specific service times for tasks like loading/unloading or customer interactions. Meeting these constraints ensures operational efficiency and customer satisfaction.

11. **Priority and Urgency**: Certain deliveries or visits may have priority levels or urgency requirements. Algorithms must prioritize routes accordingly to meet critical deadlines and optimize overall delivery performance.

12. **Multi-Objective Optimization**: Balancing multiple objectives such as minimizing travel time, reducing costs, and maximizing resource utilization requires sophisticated algorithms capable of handling complex optimization goals simultaneously.

Each of these constraints adds complexity to route optimization in logistics, highlighting the need for advanced algorithms and technologies to generate efficient and feasible routes that meet various operational requirements and constraints.



Each location must be visited exactly once
Sales rep must return to starting location
Time window constraints
Capacity constraints if sales rep is carrying goods
Vehicle specific and traffic specific constraints such as maximum speed, weight limit or fuel constraints


// src/Advantages.js

import React from 'react';

const Advantages = ({ advantages }) => {
  return (
    <div>
      <h2>Key Advantages</h2>
      <ul>
        {advantages.map((advantage, index) => (
          <li key={index}>{advantage}</li>
        ))}
      </ul>
    </div>
  );
};

export default Advantages;


// src/App.js

import React from 'react';
import Advantages from './Advantages';

const App = () => {
  const advantagesList = [
    "Cost reduction due to the most efficient routes meeting demand and constraints",
    "Improved customer satisfaction and retention through meeting delivery windows and providing accurate ETA",
    "Enhanced performance for drivers through reducing driving time and stress",
    "Increased sustainability by lowering CO2 emissions, noise pollution, and congestion",
    "Dynamic routing can help support green initiatives such as electric vehicles or low-emission zones"
  ];

  return (
    <div>
      <h1>Delivery Optimization Advantages</h1>
      <Advantages advantages={advantagesList} />
    </div>
  );
};

export default App;








Minimize total distance travelled by sales representative:
Route optimization aims to reduce the total distance travelled by a sales representative by intelligently planning the sequence of stops. Using algorithms like the Traveling Salesman Problem (TSP), the system can determine the shortest path that covers all stops efficiently. This reduces fuel costs and time spent on the road, ultimately improving productivity and customer service.
Minimize time taken to complete the route:
Efficiency in logistics requires minimizing the time taken to complete a route. By considering factors such as traffic patterns and optimal sequencing of stops, route optimization software can calculate the quickest route. This reduces delivery times and enables sales representatives to attend more meetings or visits within a given time frame, enhancing overall operational efficiency.
Accommodate dynamic changes in the route efficiently to adapt to real-time conditions:
Real-time adaptability is crucial in logistics due to unforeseen events like traffic congestion or new customer requests. Route optimization systems employ dynamic algorithms that can swiftly recalculate routes based on changing conditions. This adaptability ensures that sales representatives can adjust their routes on-the-go, maintaining efficiency and customer satisfaction while responding promptly to evolving circumstances.









import React, { useState } from 'react';
import { Card, CardContent, Typography } from '@mui/material';
import './FlipCard.css'; // Import CSS for styling

const FlipCard = () => {
  const [isFlipped, setIsFlipped] = useState(false);

  const handleCardFlip = () => {
    setIsFlipped(!isFlipped);
  };

  return (
    <Card
      className={`card ${isFlipped ? 'is-flipped' : ''}`}
      onMouseEnter={handleCardFlip}
      onMouseLeave={handleCardFlip}
    >
      <div className="card-inner">
        <CardContent>
          <Typography variant="h5" component="div">
            {isFlipped ? 'Back Content' : 'Front Content'}
          </Typography>
        </CardContent>
      </div>
    </Card>
  );
};

export default FlipCard;




.card {
  width: 200px;
  height: 200px;
  perspective: 1000px;
  transition: transform 0.6s;
}

.card-inner {
  width: 100%;
  height: 100%;
  text-align: center;
  transition: transform 0.6s;
  transform-style: preserve-3d;
}

.card.is-flipped .card-inner {
  transform: rotateY(180deg);
}

.card-front,
.card-back {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
}

.card-back {
  transform: rotateY(180deg);
}




const Item = ({ title, to, icon, selected, setSelected }) => {
  const theme = useTheme();
  const colors = tokens(theme.palette.mode);
  return (
    <MenuItem
      active={selected === title}
      style={{
        color: colors.grey[100],
      }}
      onClick={() => setSelected(title)}
      icon={icon}
    >
      <Typography>{title}</Typography>
      <Link to={to} />
    </MenuItem>
  );
};



const Sidebar = () => {
  const theme = useTheme();
  const colors = tokens(theme.palette.mode);
  const [isCollapsed, setIsCollapsed] = useState(false);
  const [selected, setSelected] = useState("Dashboard");

  return (
    <Box
      sx={{
        "& .pro-sidebar-inner": {
          background: `${colors.primary[400]} !important`,
        },
        "& .pro-icon-wrapper": {
          backgroundColor: "transparent !important",
        },
        "& .pro-inner-item": {
          padding: "5px 35px 5px 20px !important",
        },
        "& .pro-inner-item:hover": {
          color: "#868dfb !important",
        },
        "& .pro-menu-item.active": {
          color: "#6870fa !important",
        },
      }}
    >
      <ProSidebar collapsed={isCollapsed}>
        <Menu iconShape="square">
          {/* LOGO AND MENU ICON */}
          <MenuItem
            onClick={() => setIsCollapsed(!isCollapsed)}
            icon={isCollapsed ? <MenuOutlinedIcon /> : undefined}
            style={{
              margin: "10px 0 20px 0",
              color: colors.grey[100],
            }}
          >
            {!isCollapsed && (
              <Box
                display="flex"
                justifyContent="space-between"
                alignItems="center"
                ml="15px"
              >
                <Typography variant="h3" color={colors.grey[100]}>
                  ADMINS
                </Typography>
                <IconButton onClick={() => setIsCollapsed(!isCollapsed)}>
                  <MenuOutlinedIcon />
                </IconButton>
              </Box>
            )}
          </MenuItem>

          {!isCollapsed && (
            <Box mb="25px">
              <Box display="flex" justifyContent="center" alignItems="center">
                <img
                  alt="profile-user"
                  width="100px"
                  height="100px"
                  src={`../../assets/towers.jpg`}
                  style={{ cursor: "pointer", borderRadius: "50%" }}
                />
              </Box>
              <Box textAlign="center">
                <Typography
                  variant="h2"
                  color='#fb4e0b'
                  fontWeight="bold"
                  sx={{ m: "10px 0 0 0" }}
                >
                  EXL
                </Typography>
                <Typography variant="h5" color={colors.primary[100]}>
                  Lorem ipsum
                </Typography>
              </Box>
            </Box>
          )}

          <Box paddingLeft={isCollapsed ? undefined : "10%"}>
          

            <Item
              title="Home"
              to="/"
              icon={<HomeOutlinedIcon />}
              selected={selected}
              setSelected={setSelected}
            />

            <Typography
              variant="h6"
              color={colors.grey[300]}
              sx={{ m: "15px 0 5px 20px" }}
            >
              Route Optimisation
            </Typography>
            <Item
              title="Inventory"
              to="/inventory"
              icon={<PeopleOutlinedIcon />}
              selected={selected}
              setSelected={setSelected}
            />
            <Item
              title="WorkQueues"
              to="/work_queues"
              icon={<ContactsOutlinedIcon />}
              selected={selected}
              setSelected={setSelected}
            />
            <Item
              title="Data Explorer"
              to="/data_explorer"
              icon={<ReceiptOutlinedIcon />}
              selected={selected}
              setSelected={setSelected}
            />

          </Box>
        </Menu>
      </ProSidebar>
    </Box>
  );
};

export default Sidebar;





import React, { useState } from 'react';
import './InputSearch.css'; // Import the CSS file

function InputSearch() {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  const [searchResult, setSearchResult] = useState(null);

  const data = [
    { name: 'John Doe', value: '123 Main Street' },
    { name: 'Jane Smith', value: '456 Elm Street' },
    { name: 'Alice Johnson', value: '789 Oak Avenue' },
  ];

  const handleNameChange = (event) => {
    setName(event.target.value);
  };

  const handleAddressChange = (event) => {
    setAddress(event.target.value);
  };

  const search = () => {
    const searchString = `${name} - ${address}`;
    const foundItem = data.find((item) => item.name === searchString);
    setSearchResult(foundItem ? foundItem.value : 'Not Found');
  };

  return (
    <div className="input-search">
      <div className="input-row">
        <label htmlFor="name">Name:</label>
        <input type="text" id="name" placeholder="Enter Name" value={name} onChange={handleNameChange} />
      </div>
      <div className="input-row">
        <label htmlFor="address">Address:</label>
        <input type="text" id="address" placeholder="Enter Address" value={address} onChange={handleAddressChange} />
      </div>
      <button className="search-button" onClick={search}>
        Search
      </button>
      <p className="search-result">Search Result: {searchResult}</p>
    </div>
  );
}

export default InputSearch;




.input-search {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
  border: 1px solid #ddd;
  border-radius: 5px;
  margin: 20px 0;
}

.input-row {
  display: flex;
  margin-bottom: 10px;
  align-items: center;
}

.input-row label {
  margin-right: 10px;
  font-weight: bold;
}

.search-button {
  padding: 10px 20px;
  background-color: #4CAF50; /* Green */
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  margin-top: 10px;
}

.search-result {
  font-weight: bold;
  margin-top: 10px;
}




import React, { useState, useEffect } from 'react';
const XLSX = require('xlsx'); // Assuming you have `xlsx` installed using npm or yarn

function InputSearch() {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  const [searchResult, setSearchResult] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      const workbook = XLSX.readFile('path/to/your/excel_file.xlsx'); // Replace with your file path
      const sheetName = workbook.SheetNames[0]; // Get the first sheet
      const worksheet = workbook.Sheets[sheetName];
      const data = XLSX.utils.sheet_to_object(worksheet); // Convert sheet to object array
      setData(data);
    };

    fetchData();
  }, []);

  const [data, setData] = useState([]);

  const handleNameChange = (event) => {
    setName(event.target.value);
  };

  const handleAddressChange = (event) => {
    setAddress(event.target.value);
  };

  const search = () => {
    const searchString = `${name} - ${address}`;
    const foundItem = data.find((item) => item.name === searchString);
    setSearchResult(foundItem ? foundItem.value : 'Not Found');
  };

  return (
    <div>
      <input type="text" placeholder="Name" value={name} onChange={handleNameChange} />
      <input type="text" placeholder="Address" value={address} onChange={handleAddressChange} />
      <button onClick={search}>Search</button>
      <p>Search Result: {searchResult}</p>
    </div>
  );
}

export default InputSearch;
