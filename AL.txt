import React from 'react';
import { Line } from 'react-chartjs-2';
import { Chart as ChartJS, CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend } from 'chart.js';

ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend);

const LineChartComponent = ({ data }) => {
  const chartData = {
    labels: data.map((item) => item.date),
    datasets: [
      {
        label: 'Values',
        data: data.map((item) => item.value),
        borderColor: 'rgba(75, 192, 192, 1)',
        backgroundColor: 'rgba(75, 192, 192, 0.2)',
      },
    ],
  };

  return <Line data={chartData} />;
};

export default LineChartComponent;


import React, { useState } from 'react';
import ReactDOM from 'react-dom';
import { Container, Typography, CssBaseline, Button } from '@mui/material';
import DatePickerComponent from './DatePickerComponent';
import LineChartComponent from './LineChartComponent';
import * as XLSX from 'xlsx';
import dayjs from 'dayjs';

const App = () => {
  const [startDate, setStartDate] = useState(null);
  const [endDate, setEndDate] = useState(null);
  const [data, setData] = useState([]);
  const [filteredData, setFilteredData] = useState([]);

  const handleStartDateChange = (date) => {
    setStartDate(date);
  };

  const handleEndDateChange = (date) => {
    setEndDate(date);
  };

  const handleFileUpload = (event) => {
    const file = event.target.files[0];
    const reader = new FileReader();
    reader.onload = (e) => {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array' });
      const sheetName = workbook.SheetNames[0];
      const worksheet = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1 });
      const parsedData = worksheet.slice(1).map((row) => ({
        date: dayjs(row[0]).format('YYYY-MM-DD'),
        value: row[1],
      }));
      setData(parsedData);
    };
    reader.readAsArrayBuffer(file);
  };

  const filterData = () => {
    if (startDate && endDate) {
      const filtered = data.filter(
        (item) => dayjs(item.date).isAfter(dayjs(startDate)) && dayjs(item.date).isBefore(dayjs(endDate))
      );
      setFilteredData(filtered);
    }
  };

  return (
    <Container>
      <CssBaseline />
      <Typography variant="h4" align="center" marginY={4}>
        Select Date Range
      </Typography>
      <DatePickerComponent onDateChange={handleStartDateChange} />
      <DatePickerComponent onDateChange={handleEndDateChange} />
      <Button variant="contained" component="label" style={{ marginTop: 16 }}>
        Upload Excel File
        <input type="file" hidden onChange={handleFileUpload} />
      </Button>
      <Button variant="contained" onClick={filterData} style={{ marginTop: 16, marginLeft: 16 }}>
        Show Graph
      </Button>
      {filteredData.length > 0 && (
        <div style={{ marginTop: 32 }}>
          <LineChartComponent data={filteredData} />
        </div>
      )}
    </Container>
  );
};

ReactDOM.render(<App />, document.getElementById('root'));



import React, { useState } from 'react';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDayjs } from '@mui/x-date-pickers/AdapterDayjs';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { TextField, Box, Typography } from '@mui/material';
import dayjs from 'dayjs';

const DatePickerComponent = () => {
  const [selectedDate, setSelectedDate] = useState(null);

  const handleChange = (date) => {
    setSelectedDate(date);
  };

  return (
    <LocalizationProvider dateAdapter={AdapterDayjs}>
      <Box 
        display="flex" 
        flexDirection="column" 
        alignItems="center" 
        margin={2}
      >
        <DatePicker
          label="Select a date"
          value={selectedDate}
          onChange={handleChange}
          renderInput={(params) => <TextField {...params} />}
        />
        {selectedDate && (
          <Box 
            marginTop={2} 
            padding={2} 
            borderRadius={1} 
            bgcolor="#f9f9f9" 
            boxShadow={2}
          >
            <Typography variant="h6">
              Selected Date: {selectedDate ? dayjs(selectedDate).format('MMMM D, YYYY') : ''}
            </Typography>
          </Box>
        )}
      </Box>
    </LocalizationProvider>
  );
};

export default DatePickerComponent;



import React, { useState } from 'react';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { TextField, Box, Typography } from '@mui/material';
import { format } from 'date-fns';

const DatePickerComponent = () => {
  const [selectedDate, setSelectedDate] = useState(null);

  const handleChange = (date) => {
    setSelectedDate(date);
  };

  return (
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <Box 
        display="flex" 
        flexDirection="column" 
        alignItems="center" 
        margin={2}
      >
        <DatePicker
          label="Select a date"
          value={selectedDate}
          onChange={handleChange}
          renderInput={(params) => <TextField {...params} />}
        />
        {selectedDate && (
          <Box 
            marginTop={2} 
            padding={2} 
            borderRadius={1} 
            bgcolor="#f9f9f9" 
            boxShadow={2}
          >
            <Typography variant="h6">
              Selected Date: {selectedDate ? format(new Date(selectedDate), 'PPP') : ''}
            </Typography>
          </Box>
        )}
      </Box>
    </LocalizationProvider>
  );
};

export default DatePickerComponent;



import React, { useState } from 'react';
import DatePicker from 'react-datepicker';
import 'react-datepicker/dist/react-datepicker.css';
import styled from 'styled-components';

// Styled components
const DatePickerWrapper = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 20px;
`;

const StyledDatePicker = styled(DatePicker)`
  padding: 10px;
  font-size: 1rem;
  border-radius: 5px;
  border: 1px solid #ccc;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  &:focus {
    outline: none;
    border-color: #007bff;
  }
`;

const SelectedDate = styled.div`
  margin-top: 10px;
  padding: 10px;
  font-size: 1.1rem;
  color: #333;
  background-color: #f9f9f9;
  border-radius: 5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
`;

const DatePickerComponent = () => {
  const [selectedDate, setSelectedDate] = useState(null);

  const handleChange = (date) => {
    setSelectedDate(date);
  };

  return (
    <DatePickerWrapper>
      <StyledDatePicker 
        selected={selectedDate} 
        onChange={handleChange} 
        dateFormat="yyyy/MM/dd"
        placeholderText="Select a date"
      />
      {selectedDate && (
        <SelectedDate>
          Selected Date: {selectedDate.toDateString()}
        </SelectedDate>
      )}
    </DatePickerWrapper>
  );
};

export default DatePickerComponent;




import React, { useState } from 'react';
import { TextField, Button, Typography, Paper, Box, Grid } from '@mui/material';

const SearchComponent = () => {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  const [searchResult, setSearchResult] = useState('');
  const [category, setCategory] = useState('');
  const [subcategory, setSubcategory] = useState('');
  const [accessorial, setAccessorial] = useState('');
  const [phoneNumber, setPhoneNumber] = useState('');

  const handleSearch = () => {
    // Concatenate name and address
    const combinedString = name + ' ' + address;

    // Here, you would perform the search in your Excel sheet database
    // and retrieve the corresponding description based on the combined string
    // For demonstration purposes, let's assume we have a sample database
    const sampleDatabase = [
      { combinedString: "John Doe 123 Main St", description: "**Category:** Gas station\n**Subcategory:** Convenience store\n**Accessorial (RSD/DMS):** RSD\n**Phone number:** Not provided" },
      { combinedString: "Jane Smith 456 Elm St", description: "**Category:** Restaurant\n**Subcategory:** Fast food\n**Accessorial (RSD/DMS):** DMS\n**Phone number:** 123-456-7890" },
      // Add more entries as needed
    ];

    // Search the sample database for a matching entry
    const match = sampleDatabase.find(entry => entry.combinedString === combinedString);

    if (match) {
      setSearchResult('Match found!');
      // Extract values from the description
      let arr = match.description.split('\n').filter(Boolean);
      arr.forEach(line => {
        if (line.startsWith('**Category:')) {
          setCategory(line.split(':** ')[1]);
        } else if (line.startsWith('**Subcategory:')) {
          setSubcategory(line.split(':** ')[1]);
        } else if (line.startsWith('**Accessorial (RSD/DMS):')) {
          setAccessorial(line.split(':** ')[1]);
        } else if (line.startsWith('**Phone number:')) {
          setPhoneNumber(line.split(':** ')[1]);
        }
      });
    } else {
      setSearchResult('No matching details found');
      setCategory('');
      setSubcategory('');
      setAccessorial('');
      setPhoneNumber('');
    }
  };

  return (
    <Box p={2} boxShadow={3} borderRadius={2}>
      <Typography variant="h4" align="center" gutterBottom>
        Search Component
      </Typography>
      <Grid container spacing={2} alignItems="center">
        <Grid item xs={12} sm={6}>
          <TextField
            fullWidth
            variant="outlined"
            label="Enter name"
            value={name}
            onChange={e => setName(e.target.value)}
          />
        </Grid>
        <Grid item xs={12} sm={6}>
          <TextField
            fullWidth
            variant="outlined"
            label="Enter address"
            value={address}
            onChange={e => setAddress(e.target.value)}
          />
        </Grid>
        <Grid item xs={12}>
          <Button variant="contained" color="primary" onClick={handleSearch}>
            Search
          </Button>
        </Grid>
      </Grid>
      <Box mt={3}>
        <Paper elevation={3} variant="outlined">
          <Box p={2}>
            <Typography variant="h6">Search Result:</Typography>
            <Typography>{searchResult}</Typography>
            {searchResult === 'Match found!' && (
              <Box mt={2}>
                <Typography variant="h6">Details:</Typography>
                <Typography>Category: {category}</Typography>
                <Typography>Subcategory: {subcategory}</Typography>
                <Typography>Accessorial (RSD/DMS): {accessorial}</Typography>
                <Typography>Phone number: {phoneNumber}</Typography>
              </Box>
            )}
          </Box>
        </Paper>
      </Box>
    </Box>
  );
};

export default SearchComponent;





<Box display="flex" justifyContent="space-between" mb={2} marginBottom={5}>
      <Box
        display="flex"
        // backgroundColor={colors.primary[400]}
        borderRadius="3px"
        justifyContent='space-between'
      >
        {/* <InputBase sx={{ ml: 2, flex: 1 }} placeholder="Search" /> */}
        <Stack spacing={3} direction="row" p={1}>
            {/* <Button variant="text">Text</Button> */}
            <Button variant="outlined" onClick={handleClick1} size='large' sx={{backgroundColor: '', transition: 'background-color 0.3s', '&:hover': {boxShadow:4}}}><b>Product Table</b></Button>
            <Button variant="outlined" onClick={handleClick2} size='large' sx={{transition: 'background-color 0.3s', '&:hover': {boxShadow:4}}}><b>Inventory Table</b></Button>
            {/* <BasicMenu /> */}
            {/* <Button variant="outlined">Outlined</Button> */}
        </Stack>
      </Box>
    </Box>


import React, { useState, useEffect } from 'react';
import * as XLSX from 'xlsx';

const ExcelTable = ({ filePath }) => {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    const reader = new FileReader();
    reader.onload = (event) => {
      const binaryString = event.target.result;
      const workbook = XLSX.read(binaryString, { type: 'binary' });
      const sheetName = workbook.SheetNames[0]; // Assuming first sheet is the one to be used
      const excelData = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName]);
      setData(excelData.slice(0, 15)); // Limiting to first 15 rows
    };
    reader.onerror = (event) => {
      setError('Failed to read file.');
    };

    fetch(filePath)
      .then((response) => response.blob())
      .then((blob) => {
        reader.readAsBinaryString(blob);
      })
      .catch(() => {
        setError('Failed to fetch file.');
      });
  }, [filePath]);

  return (
    <div style={{ fontFamily: 'Arial, sans-serif', border: '2px solid #ddd', borderRadius: '5px', padding: '10px' }}>
      {error && <div style={{ color: 'red', marginBottom: '10px' }}>{error}</div>}
      {data && (
        <div style={{ maxHeight: '300px', overflowY: 'scroll' }}>
          <table style={{ borderCollapse: 'collapse', width: '100%' }}>
            <thead style={{ backgroundColor: '#f2f2f2' }}>
              <tr>
                {Object.keys(data[0]).map((key, index) => (
                  <th key={index} style={{ padding: '8px', border: '1px solid #ddd', textAlign: 'left' }}>
                    {key}
                  </th>
                ))}
              </tr>
            </thead>
            <tbody>
              {data.map((row, index) => (
                <tr key={index}>
                  {Object.values(row).map((cell, index) => (
                    <td key={index} style={{ padding: '8px', border: '1px solid #ddd' }}>
                      {cell}
                    </td>
                  ))}
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      )}
    </div>
  );
};

export default ExcelTable;






import React, { useState } from 'react';
import { DataGrid } from '@mui/x-data-grid';
import { mockDataTeam } from './data'; // Importing mock data from data.js

const SearchComponent = () => {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  const [searchResult, setSearchResult] = useState('');
  const [tableData, setTableData] = useState(mockDataTeam); // State to hold table data

  const handleSearch = () => {
    // Concatenate name and address
    const combinedString = name + ' ' + address;

    // Here, you would perform the search in your Excel sheet database
    // and retrieve the corresponding description based on the combined string
    // For demonstration purposes, let's assume we have a sample database
    const sampleDatabase = [
      { combinedString: "John Doe 123 Main St", description: "**Category:** Gas station\n**Subcategory:** Convenience store\n**Accessorial (RSD/DMS):** RSD\n**Phone number:** Not provided" },
      { combinedString: "Jane Smith 456 Elm St", description: "**Category:** Restaurant\n**Subcategory:** Fast food\n**Accessorial (RSD/DMS):** DMS\n**Phone number:** 123-456-7890" },
      // Add more entries as needed
    ];

    // Search the sample database for a matching entry
    const match = sampleDatabase.find(entry => entry.combinedString === combinedString);

    if (match) {
      setSearchResult('Match found!');
      // Extract values from the description
      let newEntry = {
        id: tableData.length + 1, // Generate unique ID for the new entry
        name: name,
        address: address,
        category: getCategory(match.description),
        subcategory: getSubcategory(match.description),
        accessorial: getAccessorial(match.description),
        'Phone number': getPhoneNumber(match.description)
      };
      setTableData([...tableData, newEntry]); // Append new entry to table data
    } else {
      setSearchResult('No matching details found');
    }
  };

  const getCategory = (description) => {
    // Extract category from description
    return description.split('\n').find(line => line.startsWith('**Category:')).split(':** ')[1];
  };

  const getSubcategory = (description) => {
    // Extract subcategory from description
    return description.split('\n').find(line => line.startsWith('**Subcategory:')).split(':** ')[1];
  };

  const getAccessorial = (description) => {
    // Extract accessorial from description
    return description.split('\n').find(line => line.startsWith('**Accessorial (RSD/DMS):')).split(':** ')[1];
  };

  const getPhoneNumber = (description) => {
    // Extract phone number from description
    return description.split('\n').find(line => line.startsWith('**Phone number:')).split(':** ')[1];
  };

  return (
    <div>
      <input
        type="text"
        placeholder="Enter name"
        value={name}
        onChange={e => setName(e.target.value)}
      />
      <input
        type="text"
        placeholder="Enter address"
        value={address}
        onChange={e => setAddress(e.target.value)}
      />
      <button onClick={handleSearch}>Search</button>
      <div>
        <h3>Search Result:</h3>
        <p>{searchResult}</p>
        <h3>Data Grid:</h3>
        <div style={{ height: 400, width: '100%' }}>
          <DataGrid
            rows={tableData}
            columns={[
              { field: 'id', headerName: 'ID', width: 90 },
              { field: 'name', headerName: 'Name', width: 150 },
              { field: 'address', headerName: 'Address', width: 200 },
              { field: 'category', headerName: 'Category', width: 150 },
              { field: 'subcategory', headerName: 'Subcategory', width: 200 },
              { field: 'accessorial', headerName: 'Accessorial', width: 150 },
              { field: 'Phone number', headerName: 'Phone Number', width: 150 },
            ]}
            pageSize={5}
          />
        </div>
      </div>
    </div>
  );
};

export default SearchComponent;




import React, { useState } from 'react';

const SearchComponent = () => {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  const [searchResult, setSearchResult] = useState('');
  const [category, setCategory] = useState('');
  const [subcategory, setSubcategory] = useState('');
  const [accessorial, setAccessorial] = useState('');
  const [phoneNumber, setPhoneNumber] = useState('');

  const handleSearch = () => {
    // Concatenate name and address
    const combinedString = name + ' ' + address;

    // Here, you would perform the search in your Excel sheet database
    // and retrieve the corresponding description based on the combined string
    // For demonstration purposes, let's assume we have a sample database
    const sampleDatabase = [
      { combinedString: "John Doe 123 Main St", description: "**Category:** Gas station\n**Subcategory:** Convenience store\n**Accessorial (RSD/DMS):** RSD\n**Phone number:** Not provided" },
      { combinedString: "Jane Smith 456 Elm St", description: "**Category:** Restaurant\n**Subcategory:** Fast food\n**Accessorial (RSD/DMS):** DMS\n**Phone number:** 123-456-7890" },
      // Add more entries as needed
    ];

    // Search the sample database for a matching entry
    const match = sampleDatabase.find(entry => entry.combinedString === combinedString);

    if (match) {
      setSearchResult('Match found!');
      // Extract values from the description
      let arr = match.description.split('\n').filter(Boolean);
      arr.forEach(line => {
        if (line.startsWith('**Category:')) {
          setCategory(line.split(':** ')[1]);
        } else if (line.startsWith('**Subcategory:')) {
          setSubcategory(line.split(':** ')[1]);
        } else if (line.startsWith('**Accessorial (RSD/DMS):')) {
          setAccessorial(line.split(':** ')[1]);
        } else if (line.startsWith('**Phone number:')) {
          setPhoneNumber(line.split(':** ')[1]);
        }
      });
    } else {
      setSearchResult('No matching details found');
      setCategory('');
      setSubcategory('');
      setAccessorial('');
      setPhoneNumber('');
    }
  };

  return (
    <div>
      <input
        type="text"
        placeholder="Enter name"
        value={name}
        onChange={e => setName(e.target.value)}
      />
      <input
        type="text"
        placeholder="Enter address"
        value={address}
        onChange={e => setAddress(e.target.value)}
      />
      <button onClick={handleSearch}>Search</button>
      <div>
        <h3>Search Result:</h3>
        <p>{searchResult}</p>
        {searchResult === 'Match found!' && (
          <div>
            <h4>Details:</h4>
            <p>Category: {category}</p>
            <p>Subcategory: {subcategory}</p>
            <p>Accessorial (RSD/DMS): {accessorial}</p>
            <p>Phone number: {phoneNumber}</p>
          </div>
        )}
      </div>
    </div>
  );
};

export default SearchComponent;





"**Category:** Gas station

**Subcategory:** Convenience store

**Accessorial (RSD/DMS):** RSD

**Phone number:** Not provided



arr = list(set(txt.split('\n')))
cat, subc, acc, phn = '', '', '', ''
for i in arr:
    if i[:5] == '**Cat':
        cat = (i.split(':** ')[1])
    elif i[:6] == '**Subc':
        subc = (i.split(':** ')[1])
    elif i[:10] == '**Accessor':
        acc = (i.split(':** ')[1])
    elif i[:7] == '**Phone':
        phn = (i.split(':** ')[1])
 
print(cat, subc, acc, phn)



import React, { useState } from 'react';

const SearchComponent = () => {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  const [searchResult, setSearchResult] = useState('');

  const handleSearch = () => {
    // Concatenate name and address
    const combinedString = name + ' ' + address;

    // Here, you would perform the search in your Excel sheet database
    // and retrieve the corresponding description based on the combined string
    // For demonstration purposes, let's assume we have a sample database
    const sampleDatabase = [
      { combinedString: "John Doe 123 Main St", description: "Description for John Doe" },
      { combinedString: "Jane Smith 456 Elm St", description: "Description for Jane Smith" },
      // Add more entries as needed
    ];

    // Search the sample database for a matching entry
    const match = sampleDatabase.find(entry => entry.combinedString === combinedString);

    if (match) {
      setSearchResult(match.description);
    } else {
      setSearchResult('No matching details found');
    }
  };

  return (
    <div>
      <input
        type="text"
        placeholder="Enter name"
        value={name}
        onChange={e => setName(e.target.value)}
      />
      <input
        type="text"
        placeholder="Enter address"
        value={address}
        onChange={e => setAddress(e.target.value)}
      />
      <button onClick={handleSearch}>Search</button>
      <div>
        <h3>Search Result:</h3>
        <p>{searchResult}</p>
      </div>
    </div>
  );
};

export default SearchComponent;







import React, { useState } from 'react';
import { Box, TextField } from '@mui/material';

const SearchBar = ({ onSearch }) => {
  const [searchTerm, setSearchTerm] = useState('');

  const handleChange = (event) => {
    setSearchTerm(event.target.value);
    // Call the onSearch callback with the current search term
    onSearch(event.target.value);
  };

  return (
    <Box mb={2}>
      <TextField
        label="Search"
        variant="outlined"
        value={searchTerm}
        onChange={handleChange}
        fullWidth
      />
    </Box>
  );
};

export default SearchBar;




import React, { useState } from 'react';
import { Box } from '@mui/material';
import { DataGrid } from '@mui/x-data-grid';
import { mockDataAlgorithm } from '../../data/mockData';
import SearchBar from './SearchBar';

const Algorithm = () => {
  const [filteredRows, setFilteredRows] = useState(mockDataAlgorithm);

  const handleSearch = (searchTerm) => {
    // Filter the rows based on the search term
    const filteredData = mockDataAlgorithm.filter((row) =>
      Object.values(row).some((value) =>
        value.toString().toLowerCase().includes(searchTerm.toLowerCase())
      )
    );
    setFilteredRows(filteredData);
  };

  // Define your columns and other configurations for DataGrid

  return (
    <Box m="20px">
      <SearchBar onSearch={handleSearch} />
      <DataGrid rows={filteredRows} columns={columns} />
    </Box>
  );
};

export default Algorithm;






import { Box } from "@mui/material";
import { DataGrid, GridToolbar } from "@mui/x-data-grid";
import { tokens } from "../../theme";
import Header from "../../components/Header";
import { useTheme } from "@mui/material";
import { mockDataAlgorithm } from "../../data/mockData";

const Algorithm = () => {
  const theme = useTheme();
  const colors = tokens(theme.palette.mode);

  const columns = [
    { field: "id", headerName: "ID", flex: 0.05 },
    { field: "Algorithm", headerName: "Algorithm" , flex: 0.2},
    {
      field: "Computation Time",
      headerName: "Computation Time",
      flex: 0.1,
      cellClassName: "name-column--cell",
    },
    {
      field: "Accuracy",
      headerName: "Accuracy",
      type: "number",
      headerAlign: "left",
      align: "left",
      flex: 0.1
    },
    {
        field: "Scalibility",
        headerName: "Scalibility",
        type: "number",
        headerAlign: "left",
        align: "left",
        flex: 0.1
      },
    {
      field: "Idea for",
      headerName: "Idea for",
      type: "number",
      headerAlign: "left",
      align: "left",
      flex: 0.4
    },
  ];

  return (
    <Box m="20px">
      <Header
        // title="Algorithms"//"CONTACTS"
        // subtitle="List of Contacts for Future Reference"
      />
      <Box
        m="40px 0 0 0"
        height="75vh"
        sx={{
            "& .MuiDataGrid-root": {
              border: "none",
              fontSize: 20
            },
            "& .MuiDataGrid-cell": {
              borderBottom: "none",
              fontSize: 15    
            },
            "& .name-column--cell": {
              color: colors.greenAccent[300],
            },
            "& .MuiDataGrid-columnHeaders": {
              backgroundColor: 'black',
              borderBottom: "none",
            },
            "& .MuiDataGrid-virtualScroller": {
              backgroundColor: colors.primary[400],
            },
            "& .MuiDataGrid-footerContainer": {
              borderTop: "none",
              backgroundColor: colors.blueAccent[700],
            },
            "& .MuiCheckbox-root": {
              color: `${colors.greenAccent[200]} !important`,
            },
            "& .MuiDataGrid-toolbarContainer .MuiButton-text": {
              color: `${colors.grey[100]} !important`,
            },
          }}
        >
          <style>
          {`
            .MuiDataGrid-root .MuiDataGrid-colCellWrapper,
            .MuiDataGrid-root .MuiDataGrid-cell {
              border-right: 1px solid #e0e0e0;
              border-bottom: 1px solid #e0e0e0;
            }
          `}
        </style>
        <DataGrid
          rows={mockDataAlgorithm}
          columns={columns}
          density="comfortable"
        //   initialState={{
        //     density: 'comfortable'}}
        //   components={{ Toolbar: GridToolbar }}
        />
      </Box>
    </Box>
  );
};

export default Algorithm;







ERROR in ./src/scenes/global/Sidebar.jsx 10:0-47
Module not found: Error: Can't resolve 'react-pro-sidebar/dist/css/styles.css' in 'C:\D\Access locate\al-admin\src\scenes\global'
ERROR in ./src/scenes/global/Sidebar.jsx 87:35-45
export 'ProSidebar' (imported as 'ProSidebar') was not found in 'react-pro-sidebar' (possible exports: LevelContext, Menu, MenuContext, MenuItem, MenuItemFR, ProSidebarProvider, Sidebar, SidebarContext, SubMenu, SubMenuFR, menuClasses, sidebarClasses, useProSidebar)



import React from 'react';
import { Dialog, DialogTitle, DialogContent } from '@mui/material';
import ReactPlayer from 'react-player';

const VideoDialog = ({ open, handleClose, videoPath }) => {
  return (
    <Dialog open={open} onClose={handleClose}>
      <DialogTitle>Video Dialog</DialogTitle>
      <DialogContent>
        {/* Embedding the video player */}
        <ReactPlayer url={videoPath} controls={true} width="100%" height="100%" />
      </DialogContent>
    </Dialog>
  );
};

export default VideoDialog;

import React, { useState } from 'react';
import Button from '@mui/material/Button';
import VideoDialog from './VideoDialog';

const App = () => {
  const [open, setOpen] = useState(false);
  const videoPath = '/path/to/your/local/video.mp4'; // Replace with the path to your local video file

  const handleOpen = () => {
    setOpen(true);
  };

  const handleClose = () => {
    setOpen(false);
  };

  return (
    <div>
      <Button variant="outlined" onClick={handleOpen}>
        Open Video Dialog
      </Button>
      <VideoDialog open={open} handleClose={handleClose} videoPath={videoPath} />
    </div>
  );
};

export default App;



<style>
        {`
          .MuiDataGrid-root .MuiDataGrid-colCellWrapper,
          .MuiDataGrid-root .MuiDataGrid-cell {
            border-right: 1px solid #e0e0e0;
            border-bottom: 1px solid #e0e0e0;
          }
        `}
      </style>



const customStyles = {
    components: {
      Cell: {
        style: {
          fontSize: '16px', // Adjust the font size as needed
        },
      },
    },
  };



[
  {
    "Algorithm": "Mixed Integer Linear Programming",
    "Computation Time": "Medium",
    "Accuracy": "High",
    "Scalibility": "Medium",
    "Idea for": "Linear objective function\nMedium no. of variables\nLow no. of constraints"
  },
  {
    "Algorithm": "Non Linear Programming",
    "Computation Time": "High",
    "Accuracy": "High",
    "Scalibility": "Low",
    "Idea for": "Linear/Non-Linear objective function\nMedium no. of variables\nLow no. of constraints"
  },
  {
    "Algorithm": "Genetic Algorithm",
    "Computation Time": "High",
    "Accuracy": "Medium",
    "Scalibility": "Low",
    "Idea for": "Linear/Non-Linear objective function\nLow no. of variables\nMedium no. of constraints"
  },
  {
    "Algorithm": "Particle Swarm Optimization",
    "Computation Time": "High",
    "Accuracy": "Medium",
    "Scalibility": "Low",
    "Idea for": "Linear/Non-Linear objective function\nLow no. of variables\nMedium no. of constraints"
  },
  {
    "Algorithm": "Step Optimization",
    "Computation Time": "Medium",
    "Accuracy": "Medium",
    "Scalibility": "Medium",
    "Idea for": "Linear/Non-Linear objective function\nMedium no. of variables\nMedium no. of constraints"
  },
  {
    "Algorithm": "Custom Heuristic",
    "Computation Time": "Low",
    "Accuracy": "Medium",
    "Scalibility": "Medium",
    "Idea for": "Linear/Non-Linear objective function\nHigh no. of variables\nHigh no. of constraints"
  }
]




<Box
    gridColumn="span 6"
    gridRow="span 1"
    backgroundColor={'#f2f0f0'}
    display="flex"
    alignItems="center"
    justifyContent="center"
    >
    <Typography gutterBottom variant="h5" component="div">
    Each location must be visited exactly once  
    </Typography>
</Box>


<React.Fragment>
        <Box
          gridColumn="span 8"
          gridRow="span 2"
          backgroundColor={colors.primary[400]}
          onClick={handleClickOpen}
        >
          <Dialog
        open={open}
        onClose={handleClose}
        aria-labelledby="alert-dialog-title"
        aria-describedby="alert-dialog-description"
        fullWidth={true}
        maxWidth='xl'
        onClick={(e) => e.stopPropagation()}
      >
        <DialogTitle  id="alert-dialog-title">
        </DialogTitle>
        <DialogContent>
        <Contacts />
          {/* <DialogContentText id="alert-dialog-description">
            Let Google help apps determine location. This means sending anonymous
            location data to Google, even when no apps are running.
          </DialogContentText> */}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>Close</Button>
          {/* <Button onClick={handleClose} autoFocus>
            Agree
          </Button> */}
        </DialogActions>
      </Dialog>
        </React.Fragment>



Yes, you can optimize your React component by using an array to store your constraint details and then mapping over this array to dynamically render the Accordion components. This approach allows you to avoid repetitive code and efficiently generate multiple Accordion elements with unique content. Here's an example of how you can achieve this:

```jsx
import React from 'react';
import { Accordion, AccordionSummary, AccordionDetails, Typography } from '@material-ui/core';
import ExpandMoreIcon from '@material-ui/icons/ExpandMore';

const constraintData = [
  {
    title: 'Each location must be visited exactly once',
    description: 'This constraint ensures that every stop in the route is covered efficiently without revisiting the same location. By adhering to this rule, route optimization algorithms can focus on finding the shortest or most time-efficient path that fulfills all required visits.',
  },
  {
    title: 'Sales representative must return to starting location',
    description: 'Requiring the representative to return to the starting point ensures the completion of a round trip. This constraint impacts route planning significantly, influencing the sequence and order of visited locations to optimize both time and distance.',
  },
  // Add more constraint objects as needed
];

const RouteConstraintsAccordion = () => {
  return (
    <>
      {constraintData.map((constraint, index) => (
        <Accordion key={index} defaultExpanded>
          <AccordionSummary
            expandIcon={<ExpandMoreIcon />}
            aria-controls={`panel${index + 1}-content`}
            id={`panel${index + 1}-header`}
          >
            <Typography>{constraint.title}</Typography>
          </AccordionSummary>
          <AccordionDetails>
            <Typography>{constraint.description}</Typography>
          </AccordionDetails>
        </Accordion>
      ))}
    </>
  );
};

export default RouteConstraintsAccordion;
```

In this example:

- `constraintData` is an array of objects where each object represents a route optimization constraint. Each object contains a `title` (constraint heading) and a `description` (explanation of the constraint).
- The `RouteConstraintsAccordion` component maps over the `constraintData` array to dynamically render multiple `Accordion` components based on the data in the array.
- Inside the `map` function, each `Accordion` component is rendered with its respective `AccordionSummary` (using the constraint title as the summary) and `AccordionDetails` (using the constraint description).

By using this approach, you can easily manage and update your route optimization constraints in the `constraintData` array without having to manually duplicate and modify the Accordion components in your React code. Each constraint is rendered dynamically based on the data provided in the array.



<Accordion defaultExpanded>
        <AccordionSummary
          expandIcon={<ExpandMoreIcon />}
          aria-controls="panel1-content"
          id="panel1-header"
        >
          <Typography>Each location must be visited exactly once</Typography>
        </AccordionSummary>
        <AccordionDetails>
          <Typography>
          This constraint ensures that every stop in the route is covered efficiently without revisiting the same location. By adhering to this rule, route optimization algorithms can focus on finding the shortest or most time-efficient path that fulfills all required visits.
          </Typography>
        </AccordionDetails>
      </Accordion>

1. **Each location must be visited exactly once**: This constraint ensures that every stop in the route is covered efficiently without revisiting the same location. By adhering to this rule, route optimization algorithms can focus on finding the shortest or most time-efficient path that fulfills all required visits.

2. **Sales representative must return to starting location**: Requiring the representative to return to the starting point ensures the completion of a round trip. This constraint impacts route planning significantly, influencing the sequence and order of visited locations to optimize both time and distance.

3. **Time window constraints**: Time windows specify the permissible time range for arriving at and departing from each location. Adhering to these constraints is crucial to meeting customer commitments and avoiding penalties for late deliveries, making route planning more complex but essential for customer satisfaction.

4. **Capacity constraints if sales representative is carrying goods**: If the sales representative is transporting goods, capacity constraints come into play. Each location may have a limit on the amount of goods that can be delivered or picked up, necessitating careful consideration in the route plan to avoid exceeding these limits.

5. **Vehicle-specific and traffic-specific constraints**: Different vehicles may have varying capabilities and limitations, such as maximum speed, weight limits, or fuel constraints. Traffic conditions and road characteristics also impact route optimization, requiring algorithms to account for these factors to ensure safe and efficient navigation. These constraints influence route decisions to optimize vehicle performance and compliance with regulations.

Certainly! Here are additional headings and constraint details relevant to route optimization in logistics:

6. **Geographical Constraints**: Certain routes may be restricted due to geographical factors like road closures, bridges, tolls, or restricted areas. Route optimization algorithms must consider these constraints to plan feasible and legal paths.

7. **Vehicle Types and Features**: Different vehicles (e.g., trucks, vans, cars) have unique capabilities and limitations. Constraints such as vehicle dimensions, turning radius, and special equipment requirements (like refrigeration) affect route planning to ensure vehicle suitability for each segment of the journey.

8. **Dynamic Traffic Conditions**: Real-time traffic information influences route choices to avoid congestion and delays. Algorithms must incorporate traffic patterns, accidents, and road closures to adjust routes dynamically for optimal efficiency.

9. **Environmental Factors**: Constraints related to environmental regulations, emission zones, or eco-friendly routes may influence route selection to minimize ecological impact and adhere to sustainability goals.

10. **Service Time Constraints**: Some locations may require specific service times for tasks like loading/unloading or customer interactions. Meeting these constraints ensures operational efficiency and customer satisfaction.

11. **Priority and Urgency**: Certain deliveries or visits may have priority levels or urgency requirements. Algorithms must prioritize routes accordingly to meet critical deadlines and optimize overall delivery performance.

12. **Multi-Objective Optimization**: Balancing multiple objectives such as minimizing travel time, reducing costs, and maximizing resource utilization requires sophisticated algorithms capable of handling complex optimization goals simultaneously.

Each of these constraints adds complexity to route optimization in logistics, highlighting the need for advanced algorithms and technologies to generate efficient and feasible routes that meet various operational requirements and constraints.



Each location must be visited exactly once
Sales rep must return to starting location
Time window constraints
Capacity constraints if sales rep is carrying goods
Vehicle specific and traffic specific constraints such as maximum speed, weight limit or fuel constraints


// src/Advantages.js

import React from 'react';

const Advantages = ({ advantages }) => {
  return (
    <div>
      <h2>Key Advantages</h2>
      <ul>
        {advantages.map((advantage, index) => (
          <li key={index}>{advantage}</li>
        ))}
      </ul>
    </div>
  );
};

export default Advantages;


// src/App.js

import React from 'react';
import Advantages from './Advantages';

const App = () => {
  const advantagesList = [
    "Cost reduction due to the most efficient routes meeting demand and constraints",
    "Improved customer satisfaction and retention through meeting delivery windows and providing accurate ETA",
    "Enhanced performance for drivers through reducing driving time and stress",
    "Increased sustainability by lowering CO2 emissions, noise pollution, and congestion",
    "Dynamic routing can help support green initiatives such as electric vehicles or low-emission zones"
  ];

  return (
    <div>
      <h1>Delivery Optimization Advantages</h1>
      <Advantages advantages={advantagesList} />
    </div>
  );
};

export default App;








Minimize total distance travelled by sales representative:
Route optimization aims to reduce the total distance travelled by a sales representative by intelligently planning the sequence of stops. Using algorithms like the Traveling Salesman Problem (TSP), the system can determine the shortest path that covers all stops efficiently. This reduces fuel costs and time spent on the road, ultimately improving productivity and customer service.
Minimize time taken to complete the route:
Efficiency in logistics requires minimizing the time taken to complete a route. By considering factors such as traffic patterns and optimal sequencing of stops, route optimization software can calculate the quickest route. This reduces delivery times and enables sales representatives to attend more meetings or visits within a given time frame, enhancing overall operational efficiency.
Accommodate dynamic changes in the route efficiently to adapt to real-time conditions:
Real-time adaptability is crucial in logistics due to unforeseen events like traffic congestion or new customer requests. Route optimization systems employ dynamic algorithms that can swiftly recalculate routes based on changing conditions. This adaptability ensures that sales representatives can adjust their routes on-the-go, maintaining efficiency and customer satisfaction while responding promptly to evolving circumstances.









import React, { useState } from 'react';
import { Card, CardContent, Typography } from '@mui/material';
import './FlipCard.css'; // Import CSS for styling

const FlipCard = () => {
  const [isFlipped, setIsFlipped] = useState(false);

  const handleCardFlip = () => {
    setIsFlipped(!isFlipped);
  };

  return (
    <Card
      className={`card ${isFlipped ? 'is-flipped' : ''}`}
      onMouseEnter={handleCardFlip}
      onMouseLeave={handleCardFlip}
    >
      <div className="card-inner">
        <CardContent>
          <Typography variant="h5" component="div">
            {isFlipped ? 'Back Content' : 'Front Content'}
          </Typography>
        </CardContent>
      </div>
    </Card>
  );
};

export default FlipCard;




.card {
  width: 200px;
  height: 200px;
  perspective: 1000px;
  transition: transform 0.6s;
}

.card-inner {
  width: 100%;
  height: 100%;
  text-align: center;
  transition: transform 0.6s;
  transform-style: preserve-3d;
}

.card.is-flipped .card-inner {
  transform: rotateY(180deg);
}

.card-front,
.card-back {
  position: absolute;
  width: 100%;
  height: 100%;
  backface-visibility: hidden;
}

.card-back {
  transform: rotateY(180deg);
}




const Item = ({ title, to, icon, selected, setSelected }) => {
  const theme = useTheme();
  const colors = tokens(theme.palette.mode);
  return (
    <MenuItem
      active={selected === title}
      style={{
        color: colors.grey[100],
      }}
      onClick={() => setSelected(title)}
      icon={icon}
    >
      <Typography>{title}</Typography>
      <Link to={to} />
    </MenuItem>
  );
};



const Sidebar = () => {
  const theme = useTheme();
  const colors = tokens(theme.palette.mode);
  const [isCollapsed, setIsCollapsed] = useState(false);
  const [selected, setSelected] = useState("Dashboard");

  return (
    <Box
      sx={{
        "& .pro-sidebar-inner": {
          background: `${colors.primary[400]} !important`,
        },
        "& .pro-icon-wrapper": {
          backgroundColor: "transparent !important",
        },
        "& .pro-inner-item": {
          padding: "5px 35px 5px 20px !important",
        },
        "& .pro-inner-item:hover": {
          color: "#868dfb !important",
        },
        "& .pro-menu-item.active": {
          color: "#6870fa !important",
        },
      }}
    >
      <ProSidebar collapsed={isCollapsed}>
        <Menu iconShape="square">
          {/* LOGO AND MENU ICON */}
          <MenuItem
            onClick={() => setIsCollapsed(!isCollapsed)}
            icon={isCollapsed ? <MenuOutlinedIcon /> : undefined}
            style={{
              margin: "10px 0 20px 0",
              color: colors.grey[100],
            }}
          >
            {!isCollapsed && (
              <Box
                display="flex"
                justifyContent="space-between"
                alignItems="center"
                ml="15px"
              >
                <Typography variant="h3" color={colors.grey[100]}>
                  ADMINS
                </Typography>
                <IconButton onClick={() => setIsCollapsed(!isCollapsed)}>
                  <MenuOutlinedIcon />
                </IconButton>
              </Box>
            )}
          </MenuItem>

          {!isCollapsed && (
            <Box mb="25px">
              <Box display="flex" justifyContent="center" alignItems="center">
                <img
                  alt="profile-user"
                  width="100px"
                  height="100px"
                  src={`../../assets/towers.jpg`}
                  style={{ cursor: "pointer", borderRadius: "50%" }}
                />
              </Box>
              <Box textAlign="center">
                <Typography
                  variant="h2"
                  color='#fb4e0b'
                  fontWeight="bold"
                  sx={{ m: "10px 0 0 0" }}
                >
                  EXL
                </Typography>
                <Typography variant="h5" color={colors.primary[100]}>
                  Lorem ipsum
                </Typography>
              </Box>
            </Box>
          )}

          <Box paddingLeft={isCollapsed ? undefined : "10%"}>
          

            <Item
              title="Home"
              to="/"
              icon={<HomeOutlinedIcon />}
              selected={selected}
              setSelected={setSelected}
            />

            <Typography
              variant="h6"
              color={colors.grey[300]}
              sx={{ m: "15px 0 5px 20px" }}
            >
              Route Optimisation
            </Typography>
            <Item
              title="Inventory"
              to="/inventory"
              icon={<PeopleOutlinedIcon />}
              selected={selected}
              setSelected={setSelected}
            />
            <Item
              title="WorkQueues"
              to="/work_queues"
              icon={<ContactsOutlinedIcon />}
              selected={selected}
              setSelected={setSelected}
            />
            <Item
              title="Data Explorer"
              to="/data_explorer"
              icon={<ReceiptOutlinedIcon />}
              selected={selected}
              setSelected={setSelected}
            />

          </Box>
        </Menu>
      </ProSidebar>
    </Box>
  );
};

export default Sidebar;





import React, { useState } from 'react';
import './InputSearch.css'; // Import the CSS file

function InputSearch() {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  const [searchResult, setSearchResult] = useState(null);

  const data = [
    { name: 'John Doe', value: '123 Main Street' },
    { name: 'Jane Smith', value: '456 Elm Street' },
    { name: 'Alice Johnson', value: '789 Oak Avenue' },
  ];

  const handleNameChange = (event) => {
    setName(event.target.value);
  };

  const handleAddressChange = (event) => {
    setAddress(event.target.value);
  };

  const search = () => {
    const searchString = `${name} - ${address}`;
    const foundItem = data.find((item) => item.name === searchString);
    setSearchResult(foundItem ? foundItem.value : 'Not Found');
  };

  return (
    <div className="input-search">
      <div className="input-row">
        <label htmlFor="name">Name:</label>
        <input type="text" id="name" placeholder="Enter Name" value={name} onChange={handleNameChange} />
      </div>
      <div className="input-row">
        <label htmlFor="address">Address:</label>
        <input type="text" id="address" placeholder="Enter Address" value={address} onChange={handleAddressChange} />
      </div>
      <button className="search-button" onClick={search}>
        Search
      </button>
      <p className="search-result">Search Result: {searchResult}</p>
    </div>
  );
}

export default InputSearch;




.input-search {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px;
  border: 1px solid #ddd;
  border-radius: 5px;
  margin: 20px 0;
}

.input-row {
  display: flex;
  margin-bottom: 10px;
  align-items: center;
}

.input-row label {
  margin-right: 10px;
  font-weight: bold;
}

.search-button {
  padding: 10px 20px;
  background-color: #4CAF50; /* Green */
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
  margin-top: 10px;
}

.search-result {
  font-weight: bold;
  margin-top: 10px;
}




import React, { useState, useEffect } from 'react';
const XLSX = require('xlsx'); // Assuming you have `xlsx` installed using npm or yarn

function InputSearch() {
  const [name, setName] = useState('');
  const [address, setAddress] = useState('');
  const [searchResult, setSearchResult] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      const workbook = XLSX.readFile('path/to/your/excel_file.xlsx'); // Replace with your file path
      const sheetName = workbook.SheetNames[0]; // Get the first sheet
      const worksheet = workbook.Sheets[sheetName];
      const data = XLSX.utils.sheet_to_object(worksheet); // Convert sheet to object array
      setData(data);
    };

    fetchData();
  }, []);

  const [data, setData] = useState([]);

  const handleNameChange = (event) => {
    setName(event.target.value);
  };

  const handleAddressChange = (event) => {
    setAddress(event.target.value);
  };

  const search = () => {
    const searchString = `${name} - ${address}`;
    const foundItem = data.find((item) => item.name === searchString);
    setSearchResult(foundItem ? foundItem.value : 'Not Found');
  };

  return (
    <div>
      <input type="text" placeholder="Name" value={name} onChange={handleNameChange} />
      <input type="text" placeholder="Address" value={address} onChange={handleAddressChange} />
      <button onClick={search}>Search</button>
      <p>Search Result: {searchResult}</p>
    </div>
  );
}

export default InputSearch;
